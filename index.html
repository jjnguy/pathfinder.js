<!DOCTYPE html>
<html>
<head>
  <title>Pathfinder</title>
  <style>
      canvas {
        border: 1px solid black;
        cursor: default;
      }
  </style>
</head>
<body>
  <canvas id="canvas2"></canvas>
  <button onclick="doIt()">step path</button>
  <button onclick="doItAll()">find path</button>
  <button onclick="doItSlow()">slomo path</button>
  <script>
    var pointMemory = {};
    function pointNameToPoint(ptName) {
      if (pointMemory[ptName]) return pointMemory[ptName];
      var result = {
        x: parseInt(ptName.split('+')[0]),
        y: parseInt(ptName.split('+')[1])
      };
      pointMemory[ptName] = result;
      return result;
    }

    function Maze2(canvas) {
      var self = this;

      var height = 8;
      var width = 8;

      var walls = {};
      var currentSln = reset();

      var start = { x: 0, y: 0 };
      var end = { x: width - 1, y: height - 1 };

      self.gridWidth = 10;

      var ctx = canvas.getContext('2d');
      self.draw = function () {
        canvas.width = width * self.gridWidth;
        canvas.height = height * self.gridWidth;

        for (var closed in currentSln.closedSet.all()) {
          var point = pointNameToPoint(closed);
          var translatedPoint = pointToCanvasPoint(point);
          ctx.fillStyle = 'black';
          //ctx.fillText('' + self.closedSet[closed].distanceTo, translatedPoint.x, translatedPoint.y);
          drawPointOnCanvas(ctx, point, 'lavender');
        }

        for (var open in currentSln.openSet.all()) {
          drawPointOnCanvas(ctx, pointNameToPoint(open), 'lightgreen');
        }

        for (var wallIdx in walls) {
          drawPointOnCanvas(ctx, pointNameToPoint(wallIdx), 'black');
        }

        for (var pathIdx in currentSln.finalPath) {
          drawPointOnCanvas(ctx, pointNameToPoint(currentSln.finalPath[pathIdx].name), 'lightblue');
        }
        drawPointOnCanvas(ctx, start, 'green');
        drawPointOnCanvas(ctx, end, 'red');
      };

      function reset() {
        return new Djk({ x: 0, y: 0 }, { x: height - 1, y: height - 1 }, new Graph(height, walls));
      }

      self.drawPath = function () {
        var current = reset();
        do {
          var result = currentSln.advance();
          if (result.success) return result.distanceTo;
          else current = result.current;
        } while (Object.keys(currentSln.openSet).length != 0);
        return 'no solution';
      };

      self.addWall = function (point) {
        walls[pointToName(point)] = point;
        self.draw();
      };

      function drawPointOnCanvas(ctx, point, color) {
        ctx.fillStyle = color;
        var translatedPoint = pointToCanvasPoint(point);
        ctx.fillRect(translatedPoint.x, translatedPoint.y, self.gridWidth, self.gridWidth);
      }

      function pointToCanvasPoint(point) {
        return {
          x: point.x * self.gridWidth,
          y: point.y * self.gridWidth
        };
      }
    }

    function Djk(start, end, graph) {
      var self = this;

      self.openSet = new OpenSet();
      self.closedSet = new ClosedSet();

      self.openSet.add(graph.node(start));

      graph.node(start).distanceTo = 1;
      graph.node(start).path = [];
      graph.node(end).isTheEnd = true;

      self.finalPath = [];

      self.advance = function () {
        var next = self.openSet.next();
        self.closedSet.add(next);
        for (var i = 0; i < next.edges.length; i++) {
          var edge = next.edges[i];
          if (edge == undefined) continue;
          if (edge.isTheEnd) {
            self.finalPath = next.path;
            return { success: true, path: edge.path, distance: next.distanceTo + 1 };
          } else if (!self.closedSet.contains(edge.name) && (next.distanceTo + 1 < (edge.distanceTo || 1010101))) {
            edge.path = next.path.concat(edge);
            edge.distanceTo = next.distanceTo + 1;
            self.openSet.add(edge);
          }
        }
        return { success: false, current: next };
      };
    }

    function ClosedSet() {
      var self = this;

      var nodes = {};

      self.add = function (point) {
        nodes[point.name] = point;
      };
      self.contains = function (point) {
        return nodes[point.name] != undefined;
      };

      self.all = function () {
        return nodes;
      };
    }

    function OpenSet() {
      var self = this;

      var nodes = [];

      self.add = function (point) {
        for (var i = 0; i < nodes.length; i++) {
          if (point.distanceTo <= nodes[i].distanceTo) {
            nodes.splice(i, 0, point);
            return;
          }
        }
        nodes.push(point);
      };

      self.next = function () {
        return nodes.shift();
      };

      self.all = function () {
        return nodes;
      };
    }

    function Graph(height, wallSet) {
      var self = this;

      self.nodes = {};

      for (var i = 0; i < height; i++) {
        for (var j = 0; j < height; j++) {
          if (isWall({ x: i, y: j })) continue;
          self.nodes[i + '+' + j] = { name: i + '+' + j, edges: [] };
        }
      }
      for (var node in self.nodes) {
        var point = pointNameToPoint(node);
        var edges = self.nodes[node].edges;

        // potential bug here - shouldn't be adding walls into edge sets

        edges.push(self.nodes[pointToName({ x: point.x, y: point.y + 1 })]);
        edges.push(self.nodes[pointToName({ x: point.x, y: point.y - 1 })]);

        edges.push(self.nodes[pointToName({ x: point.x - 1, y: point.y })]);
        edges.push(self.nodes[pointToName({ x: point.x + 1, y: point.y })]);
      }

      function isWall(point) {
        return wallSet[pointToName(point)] != undefined;
      }

      self.node = function (point) {
        return self.nodes[pointToName(point)];
      }
    }

    //////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////























    function Maze() {
      var self = this;
      var height = 100;
      var width = 100;

      var start = { x: 0, y: 0 };
      var end = { x: width - 1, y: height - 1 };
      var walls = [];

      self.gridWidth = 10;

      self.graph = {};
      self.openSet = {};
      self.closedSet = {};
      self.finalPath = [];

      self.resetPath = function () {
        self.graph = {};
        self.openSet = {};
        self.closedSet = {};
        self.finalPath = [];

        for (var i = 0; i < width; i++) {
          for (var j = 0; j < height; j++) {
            if (isWall({ x: i, y: j })) continue;
            self.graph[i + '+' + j] = { name: i + '+' + j, edges: [] };
          }
        }
        for (var node in self.graph) {
          var point = pointNameToPoint(node);
          var edges = self.graph[node].edges;
          edges.push(self.graph[pointToName({ x: point.x, y: point.y + 1 })]);
          edges.push(self.graph[pointToName({ x: point.x, y: point.y - 1 })]);

          edges.push(self.graph[pointToName({ x: point.x - 1, y: point.y })]);
          edges.push(self.graph[pointToName({ x: point.x + 1, y: point.y })]);
        }

        self.openSet['0+0'] = self.graph['0+0'];
        self.graph['0+0'].path = [];

        var initialPoint = self.openSet[pointToName(start)];
        initialPoint.distanceTo = 1;
        var destination = self.graph[pointToName(end)];
        destination.isTheEnd = true;

        return initialPoint;
      };

      function stepNode(current) {
        for (var edgIdx in current.edges) {
          var edge = current.edges[edgIdx];
          if (edge === undefined || self.closedSet[edge.name] != undefined) continue;
          if ((edge.distanceTo || 1010101) > current.distanceTo + 1) {
            self.openSet[edge.name] = edge;
            edge.distanceTo = current.distanceTo + 1;
            edge.path = current.path.concat([current.name]);
            if (edge.isTheEnd) {
              self.finalPath = edge.path;
              return { solved: true, dist: edge.distanceTo - 1 };
            }
          }
        }

        delete self.openSet[current.name];
        self.closedSet[current.name] = current;

        var shortest = 10101010101;
        for (var nodeName in self.openSet) {
          var node = self.openSet[nodeName];
          if ((node.distanceTo || 10101010) < shortest) {
            current = node;
            shortest = node.distanceTo;
          }
        }
        return { solved: false, current: current };
      }

      self.stepPath = function (current) {
        return stepNode(current);
      };

      self.drawPath = function () {
        var current = self.resetPath();
        do {
          var result = stepNode(current);
          if (result.solved) return result.dist;
          else current = result.current;
        } while (Object.keys(self.openSet).length != 0);
        return 'no solution';
      };

      self.addWall = function (x, y) {
        walls.push(pointToName({ x: x, y: y }));
      };

      self.draw = function (canvas) {
        var ctx = canvas.getContext('2d');
        canvas.width = self.gridWidth * width;
        canvas.height = self.gridWidth * height;

        for (var closed in self.closedSet) {
          var point = pointNameToPoint(closed);
          var translatedPoint = pointToCanvasPoint(point);
          ctx.fillStyle = 'black';
          //ctx.fillText('' + self.closedSet[closed].distanceTo, translatedPoint.x, translatedPoint.y);
          drawPointOnCanvas(ctx, point, 'lavender');
        }

        for (var open in self.openSet) {
          drawPointOnCanvas(ctx, pointNameToPoint(open), 'lightgreen');
        }

        for (var wallIdx in walls) {
          drawPointOnCanvas(ctx, pointNameToPoint(walls[wallIdx]), 'black');
        }

        for (var pathIdx in self.finalPath) {
          drawPointOnCanvas(ctx, pointNameToPoint(self.finalPath[pathIdx]), 'lightblue');
        }
        drawPointOnCanvas(ctx, start, 'green');
        drawPointOnCanvas(ctx, end, 'red');
      };

      function drawPointOnCanvas(ctx, point, color) {
        ctx.fillStyle = color;
        var translatedPoint = pointToCanvasPoint(point);
        ctx.fillRect(translatedPoint.x, translatedPoint.y, self.gridWidth, self.gridWidth);
      }

      function pointToCanvasPoint(point) {
        return {
          x: point.x * self.gridWidth,
          y: point.y * self.gridWidth
        };
      }


    }

    //var maze = new Maze();
    //var canvas = document.getElementById('canvas');
    var canvas2 = document.getElementById('canvas2');
    var maze2 = new Maze2(canvas2);
    //maze.draw(canvas);
    maze2.draw(canvas2);

    canvas2.addEventListener('click', function (evnt) {
      maze2.addWall({ x: Math.floor(evnt.offsetX / maze2.gridWidth), y: Math.floor(evnt.offsetY / maze2.gridWidth) });
      maze2.draw();
    });

    var down = false;
    canvas2.addEventListener('mousedown', function (evnt) {
      down = true;
    });
    canvas2.addEventListener('mouseup', function (evnt) {
      down = false;
    });

    canvas2.addEventListener('mousemove', function (evnt) {
      if (down) {
        maze2.addWall({ x: Math.floor(evnt.offsetX / maze2.gridWidth), y: Math.floor(evnt.offsetY / maze2.gridWidth) });
        maze2.draw();
      }
    });

    function doItSlow() {
      var current = maze2.resetPath();
      setInterval(function () {
        var result = maze2.stepPath(current);
        if (result.solved) alert('done');
        else current = result.current;
        maze2.draw();
      }, 10);
    }

    function doItAll() {
      maze2.drawPath(canvas2);
      maze2.draw();
    }

    function doIt() {
      var result = maze2.stepPath(current);
      if (result.solved) alert('done');
      else current = result.current;
      maze2.draw();
    }

    function pointToName(point) {
      return point.x + '+' + point.y;
    }


  </script>
</body>
</html>
