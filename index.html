<!DOCTYPE html>
<html>
<head>
  <title>Pathfinder</title>
  <style>
    canvas {
      border: 1px solid black;
      cursor: default;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <button onclick="doIt()">step path</button>
  <button onclick="doItAll()">find path</button>
  <button onclick="doItSlow()">slomo path</button>
  <script>
    function Maze() {
      var self = this;
      var height = 100;
      var width = 100;

      var start = { x: 0, y: 0 };
      var end = { x: width - 1, y: height - 1 };
      var walls = [];

      self.gridWidth = 10;

      self.graph = {};
      self.openSet = {};
      self.closedSet = {};
      self.finalPath = [];

      self.resetPath = function () {
        self.graph = {};
        self.openSet = {};
        self.closedSet = {};
        self.finalPath = [];

        for (var i = 0; i < width; i++) {
          for (var j = 0; j < height; j++) {
            if (isWall({ x: i, y: j })) continue;
            self.graph[i + '+' + j] = { name: i + '+' + j, edges: [] };
          }
        }
        for (var node in self.graph) {
          var point = pointNameToPoint(node);
          var edges = self.graph[node].edges;
          edges.push(self.graph[pointToName({ x: point.x, y: point.y + 1 })]);
          edges.push(self.graph[pointToName({ x: point.x, y: point.y - 1 })]);

          edges.push(self.graph[pointToName({ x: point.x - 1, y: point.y })]);
          edges.push(self.graph[pointToName({ x: point.x + 1, y: point.y })]);
        }

        self.openSet['0+0'] = self.graph['0+0'];
        self.graph['0+0'].path = [];

        var initialPoint = self.openSet[pointToName(start)];
        initialPoint.distanceTo = 1;
        var destination = self.graph[pointToName(end)];
        destination.isTheEnd = true;

        return initialPoint;
      };

      function stepNode(current) {
        for (var edgIdx in current.edges) {
          var edge = current.edges[edgIdx];
          if (edge === undefined || self.closedSet[edge.name] != undefined) continue;
          if ((edge.distanceTo || 1010101) > current.distanceTo + 1) {
            self.openSet[edge.name] = edge;
            edge.distanceTo = current.distanceTo + 1;
            edge.path = current.path.concat([current.name]);
            if (edge.isTheEnd) {
              self.finalPath = edge.path;
              return { solved: true, dist: edge.distanceTo - 1 };
            }
          }
        }

        delete self.openSet[current.name];
        self.closedSet[current.name] = current;

        var shortest = 10101010101;
        for (var nodeName in self.openSet) {
          var node = self.openSet[nodeName];
          if ((node.distanceTo || 10101010) < shortest) {
            current = node;
            shortest = node.distanceTo;
          }
        }
        return { solved: false, current: current };
      }

      self.stepPath = function (current) {
        return stepNode(current);
      };

      self.drawPath = function () {
        var current = self.resetPath();
        do {
          var result = stepNode(current);
          if (result.solved) return result.dist;
          else current = result.current;
        } while (Object.keys(self.openSet).length != 0);
        return 'no solution';
      };

      self.addWall = function (x, y) {
        walls.push(pointToName({ x: x, y: y }));
      };

      self.draw = function (canvas) {
        var ctx = canvas.getContext('2d');
        canvas.width = self.gridWidth * width;
        canvas.height = self.gridWidth * height;

        for (var closed in self.closedSet) {
          var point = pointNameToPoint(closed);
          var translatedPoint = pointToCanvasPoint(point);
          ctx.fillStyle = 'black';
          //ctx.fillText('' + self.closedSet[closed].distanceTo, translatedPoint.x, translatedPoint.y);
          drawPointOnCanvas(ctx, point, 'lavender');
        }

        for (var open in self.openSet) {
          drawPointOnCanvas(ctx, pointNameToPoint(open), 'lightgreen');
        }

        for (var wallIdx in walls) {
          drawPointOnCanvas(ctx, pointNameToPoint(walls[wallIdx]), 'black');
        }

        for (var pathIdx in self.finalPath) {
          drawPointOnCanvas(ctx, pointNameToPoint(self.finalPath[pathIdx]), 'lightblue');
        }
        drawPointOnCanvas(ctx, start, 'green');
        drawPointOnCanvas(ctx, end, 'red');
      };

      function isWall(point) {
        return walls.indexOf(pointToName(point)) >= 0;
      }

      function drawPointOnCanvas(ctx, point, color) {
        ctx.fillStyle = color;
        var translatedPoint = pointToCanvasPoint(point);
        ctx.fillRect(translatedPoint.x, translatedPoint.y, self.gridWidth, self.gridWidth);
      }

      function pointToCanvasPoint(point) {
        return {
          x: point.x * self.gridWidth,
          y: point.y * self.gridWidth
        };
      }

      function pointToName(point) {
        return point.x + '+' + point.y;
      }

      var pointMemory = {};
      function pointNameToPoint(ptName) {
        if (pointMemory[ptName]) return pointMemory[ptName];
        var result = {
          x: parseInt(ptName.split('+')[0]),
          y: parseInt(ptName.split('+')[1])
        };
        pointMemory[ptName] = result;
        return result;
      }
    }

    var maze = new Maze();
    var canvas = document.getElementById('canvas');
    maze.draw(canvas);

    canvas.addEventListener('click', function (evnt) {
      maze.addWall(Math.floor(evnt.offsetX / maze.gridWidth), Math.floor(evnt.offsetY / maze.gridWidth));
      maze.draw(canvas);
    });

    var down = false;
    canvas.addEventListener('mousedown', function (evnt) {
      down = true;
    });
    canvas.addEventListener('mouseup', function (evnt) {
      down = false;
    });

    canvas.addEventListener('mousemove', function (evnt) {
      if (down) {
        maze.addWall(Math.floor(evnt.offsetX / maze.gridWidth), Math.floor(evnt.offsetY / maze.gridWidth));
        maze.draw(canvas);
      }
    });

    function doItSlow() {
      var current = maze.resetPath();
      setInterval(function () {
        var result = maze.stepPath(current);
        if (result.solved) alert('done');
        else current = result.current;
        maze.draw(canvas);
      }, 10);
    }

    function doItAll() {
      maze.drawPath(canvas);
      maze.draw(canvas);
    }

    var current = maze.resetPath();
    function doIt() {
      var result = maze.stepPath(current);
      if (result.solved) alert('done');
      else current = result.current;
      maze.draw(canvas);
    }
  </script>
</body>
</html>
